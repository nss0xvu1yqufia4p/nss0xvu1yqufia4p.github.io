# Optimizing a (5 year old) WiFi router exploit

## Intro

I found this small project recently and thought it would be interesting to write it up, this vulnerability was first disclosed around 5 years ago now so I think it is pretty safe to publish this, it is unlikely there are any routers still running this firmware.
I did not do any actual reversing of the firmware, this is just a quick analysis of the code used to perform the exploit and a performance improvement.


It was discovered that on a certain brand of router both the default WPA Key and SSID were generated from the devices serial number.
This means that knowing the serial number of the device we can generate the WPA key.
As we know the SSID, the attack works by brute forcing every possible serial number, computing the SSID, then if the SSID is a match we know that the serial number is potentially the actual serial number of the device.
For all possible serial numbers we then compute the WPA key and one of these will be the correct WiFi password.

## Analysis

The original proof of concept code for the exploit can be found here:
[https://haxx.in/upc\_keys.c](https://haxx.in/upc_keys.c)


We can see the SSID is in the form ISPXXXXXXX. The name of the ISP followed by 7 digits. The serial number is a 9 digit number.

The serial number is broken into 4 parts and the SSID is derived from these 4 values. The code loops through every possible serial number which gives:

$$
\begin{aligned}
&= (MAX0+1)*(MAX1+1)*(MAX2+1)*(MAX3+1) \\
&= (10*100*10*10000) \\
&= 100000000\;combinations
\end{aligned}
$$

However lets take a closer look at the generate\_ssid function: 

```
uint32_t upc_generate_ssid(uint32_t* data, uint32_t magic)
{
	uint32_t a, b;

	a = data[1] * 10 + data[2];
	b = data[0] * 2500000 + a * 6800 + data[3] + magic;

	return b - (((b * MAGIC2) >> 54) - (b >> 31)) * 10000000;
}
```

We can treat the variable "magic" as a constant, and data as 4 separate variables: p, q, r, s.
Now we can rewrite this as:

$$
\begin{aligned}
a &= 10q + r \\
b &= 2500000p + 6800a + s \\
ssid &= h(b + m)
\end{aligned}
$$

And now

$$ b = 2500000p + 68000q + 6800r + s $$

Where

$$
\begin{aligned}
0 &\leq p \leq 9 \\
0 &\leq q \leq 99 \\
0 &\leq r \leq 9 \\
0 &\leq s \leq 9999
\end{aligned}
$$

And h is some function that takes an integer and returns our SSID.

Now plugging in the maximum values for p, q, r and s we find: $$ 0 \leq b \leq 29303199 $$ 

So, given a value for b we can compute the SSID and we get a linear equation with 4 unknowns which when concatenated together give us the serial number.

Now, rather than brute forcing every possible serial number, we can brute force every possible value for b, then for each value of b which generates our target SSID we will find all solutions for p, q, r and s.

As p and r have the smallest constraints there are only 100 possible combinations we will start by trying every possible combination of p and r.
So we get:

$$
\begin{aligned}
b - 2500000p - 6800r &= 68000q + s \\
&= c
\end{aligned}
$$

Where $$ 0 \leq c \leq 6741999 $$

Now there are only 100 possible values for q and we can easily solve for s.

A python implementation would look something like this:

```
for i in range(0, 29303199):
	if (h(i, MAGIC_24GHZ) == target or h(i, MAGIC_5GHZ) == target):
		for p, q in product(range(9, -1, -1), range(9, -1, -1)):
			c = i - 2500000*p - 6800*q;
			if c < 0:continue;
			if c > 6741999:break;
			for r in range(100):
				s = c - 68000*r;
				if (s < 10000 and s >= 0):
					serial = "SAAP" + str(p) + str(r) + str(q) + str(s);
					print serial;
``` 

So as it is relatively trivial to recover the values for p, q, r and s for a given value of b, and we are fairly safe* to assume that the number of values which match the target will be very low, we can effectivly count only the iterations of the main for loop towards the computation, we have effectivly reduced the search space by ~70%.

Now once we have all possible solution sets for p, q, r and s we know the corresponding serial number and can easily compute the candidate WPA keys using the algorithm in the origional proof of concept code.

*We are assuming that the function h, i.e. the bit shifty stuff in the original function is a good PRNG, we could also probably solve for p, q, r and s more efficiently by using the euclidean algorithm as it is a linear Diophantine equation.
